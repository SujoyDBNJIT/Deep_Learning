# -*- coding: utf-8 -*-
"""udemy _DeepNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13piLz4pJRDkYzpcKFHWPpAkiXqFSzRs9
"""

import torch
import numpy as np
import matplotlib.pyplot as plt
import torch.nn as nn
from sklearn import datasets

n_pts = 500
x,y = datasets.make_circles(n_samples=n_pts, random_state=123, noise=0.1, factor=0.3)
x_data = torch.tensor(x).float()
y_data = torch.tensor(y.reshape(500,1)).float()
print(y_data)

def scatter_plot():
  plt.scatter(x[y==0, 0], x[y==0, 1])
  plt.scatter(x[y==1, 0], x[y==1, 1])

scatter_plot()

class Model(nn.Module):
  def __init__(self, input_size, h1, h2, output_size):
    super().__init__()
    self.linear = nn.Linear(input_size, h1)
    self.linear2 = nn.Linear(h1, h2)
    self.linear3 = nn.Linear(h2, output_size)
  def forward(self, x):
    x = torch.sigmoid(self.linear(x))
    x = torch.sigmoid(self.linear2(x))
    x = torch.sigmoid(self.linear3(x))
    return x
  def predict(self, x):
    pred = self.forward(x)
    if pred >= 0.5:
      return 1
    else: 
      return 0

torch.manual_seed(2)
model = Model(2, 4, 4, 1)
print(list(model.parameters()))

criterion = nn.BCELoss()
optimizer = torch.optim.Adam(model.parameters(), lr=0.1)

epochs = 1000
losses = []
for i in range(epochs):
  y_pred = model.forward(x_data)
  loss = criterion(y_pred, y_data)
  print("epoch:", i, "loss", loss.item())
  losses.append(loss)
  optimizer.zero_grad()
  loss.backward()
  optimizer.step()

plt.plot(range(epochs), losses)
plt.xlabel('epoch')
plt.ylabel('loss')

def plot_decision_boundary(x,y):
  x_span = np.linspace(min(x[:,0])-0.5, max(x[:, 0])+0.5)
  y_span = np.linspace(min(x[:,1])-0.5, max(x[:, 1])+0.5)
  xx, yy = np.meshgrid(x_span, y_span)
  grid = torch.tensor(np.c_[xx.ravel(), yy.ravel()]).float()
  pred_func = model.forward(grid)
  z = pred_func.view(xx.shape).detach().numpy()
  plt.contourf(xx, yy, z)

plot_decision_boundary(x,y)
scatter_plot()

plot_decision_boundary(x,y)
a = 0.25
b = 0.25
point = torch.tensor([a,b])
prediction = model.predict(point)
plt.plot([a], [b], marker='o', markersize= 10, color="red")
print ("Presiction is", prediction)
plot_decision_boundary(x,y)

